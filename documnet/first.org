** 当前日期： 2015/05/05 周二

- 通用库设计的宗旨，是提供微信处理过程中的通用功能，简化微信处理设计
  IPostProcess和IEncyptPostProcess两个接口，第一个接口是明文微信处理，
  第二个 接口是加密微信处理；用户最终使用者两个接口的实现，
  DefaultPostProcess和 DefaultEncyptPostProcess

- 用户只需实现一个PostProcessorAdapter适配器类，这个类中有各种微信请求，
  用户可以 选择实现的处理请求，可以在处理中进行内容判断、数据库查询等
  操作，根据结果返回需 要的响应

- PostProcessorAdapter适配器类，引用ResponseManager回复实体管理，以产
  生各种回复 实体。ResponseManager有两种产生回复实体的方式，一是返回默
  认形式实体，二是返回 指定xml文件格式的回复实体

- ResponseManager中设置了实体缓冲，如果缓冲实体不为空，下次取得实体时，
  不再解析 xml文件，直接从缓冲中返回实体，提高效率

- ResponseManager中可设置键对值Properties对象，可以对TextResponse、
  VideoResponse、 NewsResponse中相关内容自动替换用户使用微信通用库时，
  可以从请求中(request)的到是否加密的信息，如果未加密，可 使用
  DefaultPostProcess类，加密可使用DefaultEncyptPostProcess，同时实现自
  己的处 理器(PostProcessorAdapter适配器)，然会直接调用process，即可得
  到正确的回复串

** 当前日期: 2015/05/28 周四 
- TextResponse实现了cloneable接口，可以克隆对象，防止缓冲对象被改变，应该所有响
  应都加上cloneable接口
- Response Entity使用了XStream实现实体和XML转换
- 缓冲加大，每个响应对象形成缓冲池
- Spring mvc 可以直接获得参数，@RequestParam String timestamp, 不需要使用HttpServletRequest.getParameter("timestamp")
- Spring mvc 可以直接获得数据，@RequestBody String postData)，不需要输入流方式
- Spring mvc 可以直接返回数据@ResponseBody，不需要输出流方式
- @RequestMapping(method = RequestMethod.POST, produces = "text/html;charset=utf-8")可以保证返回数据是UTF-8格式
- 使用apache httpClient和spring-web实现https访问方式，很方便
- Active Entity使用了XStream实现实体和json转换

** 当前日期: 2015/05/29 周五 
- 使用AES加密时，当密钥大于128时，代码会抛出java.security.InvalidKeyException:
  Illegal key size or default parameters Illegal key size or default parameters是
  指密钥长度是受限制的，java运行时环境读到的是受限的policy文件。文件位于
  ${java_home}/jre/lib/security这种限制是因为美国对软件出口的控制
- 在开发者首次提交验证申请时，微信服务器将发送GET请求到填写的URL上， 并且带上四个
  参数(signature、timestamp、nonce、echostr)， 开发者通过对签名(即signature)的效
  验，来判断此条消息的真实性。 sha1加密使用了apche的commons-codec(DigestUtils)开源工具
#+begin_src jave
		// 2. 将三个参数字符串拼接成一个字符串进行sha1加密
		String temp = DigestUtils.sha1Hex(params.get(0) + params.get(1) +	params.get(2));
#+end_src
** 当前日期: 2015/06/03 周三 
- 微信返回的json串，不能直接转换为对象，需要用标识包装一下
#+begin_src java
	/** 用object标识包装json，方便json转换为对象 */
	private String jsonTemplate = "{object:json}";
	xStream.alias("object", cls);
	return (T) xStream.fromXML(json);
#+end_src

- 请求微信服务器的IP地址列表，返回的是多个ip_list，IpAddress类属性设计成List类型

#+begin_src java
{
	"ip_list":["127.0.0.1","127.0.0.1","127.0.0.1","127.0.0.1"]
}
public class IpAddresses {
	private List<String> ip_list;
}
#+end_src
  这样的json转换为IpAddress时，需要进行如下设置：
#+begin_src java
	  /** 用object标识包装json，方便json转换为对象 */
	  private String jsonTemplate = "{object:json}";
 	  XStream xStream = new XStream(new JettisonMappedXmlDriver());  
	  xStream.alias("object", IpAddress.class);
	  // 设置attribute对应类中List类型
          xStream.alias("ip_list", List.class);
   	  xStream.addImplicitCollection(IpAddress.class, "ip_list");
	  xStream.alias("ip_list", String.class);
#+end_src

- 请求微信服务器的用户列表，返回的是这样的json，转换为下面的类

#+BEGIN_SRC java
String json = "{"total":2,"count":2,"data":{"openid":["OPENID1","OPENID2"]},"next_openid":"NEXT_OPENID"}";
package com.ironside.weixin.active.entity;

import java.util.List;

/**
 * 用户列表类
 * @author 雪庭
 * @sine 1.0 at 2015年6月5日
 */
public class UserList {

	/** 关注该公众账号的总用户数 */
	private int total;
	/** 拉取的OPENID个数，最大值为10000 */
	private int count;
	/** 列表数据，OPENID的列表 */
	private UserListData data;
	/** 拉取列表的后一个用户的OPENID */
	private String next_openid; 

	/**
	 * OPENID的列表数据类
	 */
	public class UserListData {
		
		List<String> openid;

		
	}
}
#+END_SRC
  这样的json转换为UserInfo时，需要进行如下设置：
#+BEGIN_SRC java
	  /** 用object标识包装json，方便json转换为对象 */
	  private String jsonTemplate = "{object:json}";
	  XStream xStream = new XStream(new JettisonMappedXmlDriver());  
	  xStream.alias("object", UserList.class);
	  xStream.alias("data", UsereList.UserListData.class);
	  // 设置attribute对应类中List类型
	  xStream.alias("openid", List.class);
	  xStream.addImplicitCollection(UsereList.UserListData.class, "openid");
	  xStream.alias(nameOfList, String.class);
#+END_SRC

- 使用apache httpClient和spring-web实现https访问方式，最终使用
  org.springframework.web.client.RestTemplate类发起访问，但是默认的编码是
  ISO-8859-1，返回中文是乱码，需要改变RestTemplate的编码
#+begin_src java
	/*
	 * 设置RestTemplate的编码，RestTemplate默认添加HttpMessageConverter的编码是ISO-8859-1，
	 * 如果用其他编码，需要移除原有的StringHttpMessageConverter，添加指定字符集的StringHttpMessageConvert
	 */
	private void setRestTemplateCharSet(RestTemplate restTemplate, Charset charset) {
		List<HttpMessageConverter<?>> converterList = restTemplate	.getMessageConverters();
		HttpMessageConverter<?> converterTarget = null;
		for (HttpMessageConverter<?> item : converterList) {
			if (item.getClass() == StringHttpMessageConverter.class) {
				converterTarget = item;
				break;
			}
		}
		if (converterTarget != null) {
			converterList.remove(converterTarget);
		}
		HttpMessageConverter<?> converter = new StringHttpMessageConverter(charset);
		converterList.add(converter);
	}
#+end_src



